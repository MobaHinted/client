#     MobaHinted Copyright (C) 2020 Ethan Henderson <ethan@zbee.codes>    #
#  Licensed under GPLv3 - Refer to the LICENSE file for the complete text #

from datetime import datetime, timezone
from functools import cached_property
from typing import TypedDict, Required, Union

import cassiopeia
import roleidentification.utilities as cassiopeia_role_identification
import pytz
import timeago
import timeago.locales.en  # Required for building to executable

import hinter


class GameReturn(TypedDict, total=False):
    match_id: Required[int]
    map_id: Required[int]
    queue: Required[str]
    match_duration: Required[str]
    # region For individual match views
    players: Required[list[list[cassiopeia.core.match.Participant]]]
    teams_kills: Required[list[int]]
    teams_damage: Required[list[int]]
    teams_outcomes: Required[list[str]]
    teams_bans: Required[list[list[str]]]  # List of lists as it's split by team from here on
    teams_background_colors: Required[list[list[int]]]
    players_summoner_spells: Required[list[list[list[str]]]]
    players_roles: Required[list[list[str]]]
    players_kdas: Required[list[list[str]]]
    players_k_d_as: Required[list[list[str]]]
    players_kps: Required[list[list[str]]]
    players_damage: Required[list[list[str]]]
    players_damage_of_team: Required[list[list[str]]]
    players_damage_per_min: Required[list[list[str]]]
    players_vision: Required[list[list[str]]]
    players_vision_per_min: Required[list[list[str]]]
    players_cs: Required[list[list[str]]]
    players_cs_per_min: Required[list[list[str]]]
    players_items: Required[list[list[list[str]]]]
    players_key_runes: Required[list[list[str]]]
    players_secondary_rune_trees: Required[list[list[str]]]
    players_runes: Required[list[list[list[str]]]]
    # endregion For individual match views
    # region For Match History
    player: cassiopeia.core.match.Participant
    team: str
    team_kills: int
    team_damage: int
    outcome: str
    background_color: list[int]
    summoner_spells: list[str]
    role: str
    kda: str
    k_d_a: str
    damage: str
    damage_of_team: str
    damage_per_min: str
    vision: str
    vision_per_min: str
    kp: str
    cs: str
    cs_per_min: str
    items: list[str]
    key_rune: str
    secondary_rune: str
    runes: list[str]
    # endregion For Match History


class MatchData:
    # Static data
    _ = None

    # Public data
    match: GameReturn
    blue_team: int  # The keys to use when splitting the match data by team
    red_team: int

    # Data for calculating the match data
    _match: cassiopeia.core.match.Match
    _match_minutes: Union[float, None]

    # region Data generated by their superseding properties
    _teams_damage_values: Union[list[int], None]
    _teams_background_colors_values: Union[list[list[int]], None]
    _players_k_d_as_values: Union[list[list[str]], None]
    _players_kps_values: Union[list[list[str]], None]
    _players_damage_of_team_values: Union[list[list[str]], None]
    _players_damage_per_min_values: Union[list[list[str]], None]
    _players_vision_per_min_values: Union[list[list[str]], None]
    _players_cs_per_min_values: Union[list[list[str]], None]
    _players_secondary_rune_trees_values: Union[list[list[str]], None]
    _players_runes_values: Union[list[list[list[str]]], None]

    # endregion Data generated by their superseding properties

    def __init__(self, game: int, user: str = None):
        # region Making sure everything defaults back
        self._match_minutes = None
        self._teams_damage_values = None
        self._teams_background_colors_values = None
        self._players_k_d_as_values = None
        self._players_kps_values = None
        self._players_damage_of_team_values = None
        self._players_damage_per_min_values = None
        self._players_vision_per_min_values = None
        self._players_cs_per_min_values = None
        self._players_secondary_rune_trees_values = None
        self._players_runes_values = None
        # endregion Making sure everything defaults back

        self._match = hinter.cassiopeia.get_match(game, hinter.settings.region)

        # Just done here programmatically, so it's easier to adjust for if ever needed,
        # or possibly to aid in supporting other game modes in the future
        teams = [cassiopeia.data.Side.blue, cassiopeia.data.Side.red]
        self.blue_team = teams.index(cassiopeia.data.Side.blue)
        self.red_team = teams.index(cassiopeia.data.Side.red)

        self._format_game()

        if user is not None:
            self._format_game_for(user)
        else:
            self._format_game()

    def _format_game(self) -> None:
        self.match = GameReturn(
            match_id=self._match_id,
            map_id=self._map_id,
            queue=self._queue,
            match_duration=self._match_duration,
            players=self._players,
            teams_kills=self._teams_kills,
            teams_damage=self._teams_damage,
            teams_outcomes=self._teams_outcomes,
            teams_bans=self._teams_bans,
            teams_background_colors=self._teams_background_colors,
            players_summoner_spells=self._players_summoner_spells,
            players_roles=self._players_roles,
            players_kdas=self._players_kdas,
            players_k_d_as=self._players_k_d_as,
            players_kps=self._players_kps,
            players_damage=self._players_damage,
            players_damage_of_team=self._players_damage_of_team,
            players_damage_per_min=self._players_damage_per_min,
            players_vision=self._players_vision,
            players_vision_per_min=self._players_vision_per_min,
            players_cs=self._players_cs,
            players_cs_per_min=self._players_cs_per_min,
            players_items=self._players_items,
            players_key_runes=self._players_key_runes,
            players_secondary_rune_trees=self._players_secondary_rune_trees,
            players_runes=self._players_runes,
        )

    # noinspection DuplicatedCode
    def _format_game_for(self, user: str) -> None:
        team = None
        position = None

        # Find where the user is
        for _team, players in enumerate(self._players):
            for _position, player in enumerate(players):
                if player.summoner.name == user:
                    team = _team
                    position = _position
                    break

        # Short-circuit if the user is not found
        if team is None or position is None:
            return

        self.match = GameReturn(
            match_id=self._match_id,
            map_id=self._map_id,
            queue=self._queue,
            match_duration=self._match_duration,
            players=self._players,
            teams_kills=self._teams_kills,
            teams_damage=self._teams_damage,
            teams_outcomes=self._teams_outcomes,
            teams_bans=self._teams_bans,
            teams_background_colors=self._teams_background_colors,
            players_summoner_spells=self._players_summoner_spells,
            players_roles=self._players_roles,
            players_kdas=self._players_kdas,
            players_k_d_as=self._players_k_d_as,
            players_kps=self._players_kps,
            players_damage=self._players_damage,
            players_damage_of_team=self._players_damage_of_team,
            players_damage_per_min=self._players_damage_per_min,
            players_vision=self._players_vision,
            players_vision_per_min=self._players_vision_per_min,
            players_cs=self._players_cs,
            players_cs_per_min=self._players_cs_per_min,
            players_items=self._players_items,
            players_key_runes=self._players_key_runes,
            players_secondary_rune_trees=self._players_secondary_rune_trees,
            players_runes=self._players_runes,
            player=self._players[team][position],
            team=team,
            team_kills=self._teams_kills[team],
            team_damage=self._teams_damage[team],
            outcome=self._teams_outcomes[team],
            background_color=self._teams_background_colors[team],
            summoner_spells=self._players_summoner_spells[team][position],
            role=self._players_roles[team][position],
            kda=self._players_kdas[team][position],
            k_d_a=self._players_k_d_as[team][position],
            damage=self._players_damage[team][position],
            damage_of_team=self._players_damage_of_team[team][position],
            damage_per_min=self._players_damage_per_min[team][position],
            vision=self._players_vision[team][position],
            vision_per_min=self._players_vision_per_min[team][position],
            kp=self._players_kps[team][position],
            cs=self._players_cs[team][position],
            cs_per_min=self._players_cs_per_min[team][position],
            items=self._players_items[team][position],
            key_rune=self._players_key_runes[team][position],
            secondary_rune=self._players_secondary_rune_trees[team][position],
            runes=self._players_runes[team][position],
        )

    def _assemble_into_teams(self, blue_team_data: list, red_team_data: list) -> list[list]:
        teamed_data = [self._, self._]
        # Again done here like this to adjust or support other game modes
        teamed_data[self.blue_team] = blue_team_data
        teamed_data[self.red_team] = red_team_data

        return teamed_data

    @cached_property
    def _match_id(self) -> int:
        return int(self._match.id)

    @cached_property
    def _map_id(self) -> int:
        return self._match.map.id

    @cached_property
    def _queue(self) -> str:
        # noinspection PyBroadException
        try:
            queue = self._match.queue.name
        except Exception:
            return ''

        # Shorter names for the queue static data
        ranked = cassiopeia.data.Queue.ranked_solo_fives
        flex = cassiopeia.data.Queue.ranked_flex_fives
        clash = cassiopeia.data.Queue.clash
        blind = cassiopeia.data.Queue.blind_fives
        draft = cassiopeia.data.Queue.normal_draft_fives
        aram = cassiopeia.data.Queue.aram
        arena = cassiopeia.data.Queue.rings_of_wrath

        if self._match.queue == ranked or self._match.queue == ranked.name:
            queue = 'Ranked Solo'
        elif self._match.queue == flex or self._match.queue == flex.name:
            queue = 'Ranked Flex'
        elif self._match.queue == clash or self._match.queue == clash.name:
            queue = 'Clash'
        elif self._match.queue == blind or self._match.queue == blind.name:
            queue = 'Normal Blind'
        elif self._match.queue == draft or self._match.queue == draft.name:
            queue = 'Normal Draft'
        elif self._match.queue == aram or self._match.queue == aram.name:
            queue = 'ARAM'
        elif self._match.queue == arena or self._match.queue == arena.name:
            queue = 'Arena'
        else:
            queue = queue.replace('_', ' ').title()

        return queue

    @cached_property
    def _match_duration(self) -> str:
        match_length_parts = str(self._match.duration).split(':')
        match_minutes = int(match_length_parts[0] * 60)
        match_minutes += int(match_length_parts[1])
        match_minutes += int(match_length_parts[2]) / 60
        self._match_minutes = round(match_minutes, 2)

        # Calculate when the match happened
        now = datetime.now(timezone.utc)
        match_time = datetime.fromisoformat(
            str(self._match.creation)
        )

        # Format match timing and how long ago it was
        # duration = str(self._match.duration) + ' long - '  # HH:MM:SS display
        duration = f'{self._match_minutes:>3.0f}min - '
        duration += timeago.format(match_time, now)
        return duration.replace('utes', '')

    @cached_property
    def _players(self) -> list[list[cassiopeia.core.match.Participant]]:
        blue_team = []
        red_team = []

        for participant in self._match.participants:
            if participant.side == cassiopeia.data.Side.blue:
                blue_team.append(participant)
            else:
                red_team.append(participant)

        return self._assemble_into_teams(blue_team, red_team)

    @cached_property
    def _teams_kills(self) -> list[int]:
        teams_kills = [0, 0]
        teams_damage = [0, 0]

        for team, players in enumerate(self._players):
            for player in players:
                teams_kills[team] += player.stats.kills
                teams_damage[team] += player.stats.total_damage_dealt_to_champions

        self._teams_damage_values = teams_damage

        return teams_kills

    @cached_property
    def _teams_damage(self) -> list[int]:
        if self._teams_damage_values is None:
            # noinspection PyStatementEffect
            self._teams_kills

        return self._teams_damage_values

    @cached_property
    def _teams_outcomes(self) -> list[str]:
        # Short-circuit for remakes
        if self._match.is_remake:
            self._teams_background_colors_values = [
                hinter.data.constants.MATCH_COLOR_REMAKE,
                hinter.data.constants.MATCH_COLOR_REMAKE
            ]
            return ['Remake', 'Remake']

        teams_outcomes = [self._, self._]
        background_colors = [self._, self._]

        for team, player in enumerate(self._players):
            if player[0].stats.win:
                teams_outcomes[team] = 'Victory'
                background_colors[team] = hinter.data.constants.MATCH_COLOR_WIN
            else:
                teams_outcomes[team] = 'Defeat'
                background_colors[team] = hinter.data.constants.MATCH_COLOR_LOSS

        self._teams_background_colors_values = background_colors
        return teams_outcomes

    # noinspection DuplicatedCode
    @cached_property
    def _teams_bans(self) -> list[list[str]]:
        teams_bans = [[], []]

        if self._queue == 'Arena' or self._queue == 'ARAM':
            return [[''], ['']]

        for ban in self._match.blue_team.bans:
            if ban is None:
                teams_bans[self.blue_team].append(
                    hinter.UI.load_image(
                        'champion_ban-filler',
                        hinter.data.constants.IMAGE_TYPE_PIL,
                        cassiopeia.ProfileIcon(id=29, region=hinter.settings.region),
                        size=hinter.data.constants.ICON_SIZE_BAN,
                    )
                )
                continue
            teams_bans[self.blue_team].append(
                hinter.UI.load_image(
                    f'champion_ban-{ban.name}',
                    hinter.data.constants.IMAGE_TYPE_PIL,
                    ban.image,
                    size=hinter.data.constants.ICON_SIZE_BAN,
                )
            )

        for ban in self._match.red_team.bans:
            if ban is None:
                teams_bans[self.red_team].append(
                    hinter.UI.load_image(
                        'champion_ban-filler',
                        hinter.data.constants.IMAGE_TYPE_PIL,
                        cassiopeia.ProfileIcon(id=29, region=hinter.settings.region),
                        size=hinter.data.constants.ICON_SIZE_BAN,
                    )
                )
                continue
            teams_bans[self.red_team].append(
                hinter.UI.load_image(
                    f'champion_ban-{ban.name}',
                    hinter.data.constants.IMAGE_TYPE_PIL,
                    ban.image,
                    size=hinter.data.constants.ICON_SIZE_BAN,
                )
            )

        return teams_bans

    @cached_property
    def _teams_background_colors(self) -> list[list[int]]:
        if self._teams_background_colors_values is None:
            # noinspection PyStatementEffect
            self._teams_outcomes

        return self._teams_background_colors_values

    @cached_property
    def _players_summoner_spells(self) -> list[list[list[str]]]:
        players_summoner_spells = [[], []]

        for team, players in enumerate(self._players):
            for player in players:
                if self._queue == 'Arena':
                    players_summoner_spells[team].append([
                        hinter.UI.filler_image,
                        hinter.UI.filler_image,
                    ])
                    continue

                players_summoner_spells[team].append([
                    hinter.UI.load_image(
                        f'spell-{player.summoner_spell_d.name}',
                        hinter.data.constants.IMAGE_TYPE_PIL,
                        player.summoner_spell_d.image,
                        size=hinter.data.constants.ICON_SIZE_SPELL,
                    ),
                    hinter.UI.load_image(
                        f'spell-{player.summoner_spell_f.name}',
                        hinter.data.constants.IMAGE_TYPE_PIL,
                        player.summoner_spell_f.image,
                        size=hinter.data.constants.ICON_SIZE_SPELL,
                    ),
                ])

        return players_summoner_spells

    # noinspection DuplicatedCode
    @cached_property
    def _players_roles(self) -> list[list[str]]:
        renaming_roles = {
            cassiopeia.data.Lane.top_lane: 'Top',
            cassiopeia.data.Lane.jungle: 'Jungle',
            cassiopeia.data.Lane.mid_lane: 'Mid',
            cassiopeia.data.Lane.bot_lane: 'Bot',
            cassiopeia.data.Lane.utility: 'Support',
        }

        champion_order = [[], []]
        players_roles = [
            [self._, self._, self._, self._, self._],
            [self._, self._, self._, self._, self._],
        ]

        # TODO: Add item hinting

        # First set up the order the champions should be in
        for team, players in enumerate(self._players):
            for player in players:
                champion_order[team].append(player.champion.id)

        # Short-circuit for Arena and ARAM
        if self._queue == 'Arena' or self._queue == 'ARAM':
            for team, players in enumerate(self._players):
                for key, _ in enumerate(players):
                    # noinspection PyTypeChecker
                    players_roles[team][key] = ''
            return players_roles

        # Then get the roles for each champion on blue team
        blue_team_roles = cassiopeia_role_identification.get_team_roles(
            self._match.blue_team,
            hinter.ChampionRoleData
        )
        for position, champion in blue_team_roles.items():
            order = champion_order[self.blue_team].index(champion.id)
            lane = cassiopeia.data.Lane.from_match_naming_scheme(position.name.upper())
            players_roles[self.blue_team][order] = renaming_roles[lane]

        # Do the sam for red team
        red_team_roles = cassiopeia_role_identification.get_team_roles(
            self._match.red_team,
            hinter.ChampionRoleData
        )
        for position, champion in red_team_roles.items():
            order = champion_order[self.red_team].index(champion.id)
            lane = cassiopeia.data.Lane.from_match_naming_scheme(position.name.upper())
            players_roles[self.red_team][order] = renaming_roles[lane]

        return players_roles

    # noinspection PyTypeChecker,DuplicatedCode
    @cached_property
    def _players_kdas(self) -> list[list[str]]:
        players_kdas = [[], []]
        players_k_d_as = [[], []]
        players_kps = [[], []]
        teams_kills = [0, 0]

        for team, players in enumerate(self._players):
            for player in players:
                teams_kills[team] += player.stats.kills

        for team, players in enumerate(self._players):
            for player in players:
                if player.stats.deaths == 0:
                    kda = player.stats.kills + player.stats.assists
                else:
                    kda = (player.stats.kills + player.stats.assists) / player.stats.deaths
                players_kdas[team].append(
                    f'{kda:>3.1f}'
                )

                players_k_d_as[team].append(
                    f'{player.stats.kills} / {player.stats.deaths} / {player.stats.assists}'
                )

                if teams_kills[team] == 0:
                    kp = 0
                else:
                    kp = int(round((player.stats.kills + player.stats.assists) / teams_kills[team] * 100, 0))
                players_kps[team].append(f'{kp:>3}%')

        self._players_k_d_as_values = players_k_d_as
        self._players_kps_values = players_kps
        return players_kdas

    @cached_property
    def _players_k_d_as(self) -> list[list[str]]:
        if self._players_k_d_as_values is None:
            # noinspection PyStatementEffect
            self._players_kdas

        return self._players_k_d_as_values

    @cached_property
    def _players_kps(self) -> list[list[str]]:
        if self._players_kps_values is None:
            # noinspection PyStatementEffect
            self._players_kdas

        return self._players_kps_values

    # noinspection PyTypeChecker,DuplicatedCode
    @cached_property
    def _players_damage(self) -> list[list[str]]:
        players_damage = [[], []]
        players_damage_of_team = [[], []]
        players_damage_per_min = [[], []]
        teams_damage = [0, 0]

        for team, players in enumerate(self._players):
            for player in players:
                teams_damage[team] += player.stats.total_damage_dealt_to_champions

        for team, players in enumerate(self._players):
            for player in players:
                players_damage[team].append(f'{player.stats.total_damage_dealt_to_champions:,} Dmg')

                if teams_damage[team] == 0:
                    damage_of_team = 0
                else:
                    damage_of_team = int(round(
                        player.stats.total_damage_dealt_to_champions / teams_damage[team] * 100,
                        0))
                players_damage_of_team[team].append(f'{damage_of_team}%')

                if self._match_minutes == 0:
                    damage_per_min = player.stats.total_damage_dealt_to_champions
                else:
                    damage_per_min = int(round(
                        player.stats.total_damage_dealt_to_champions / self._match_minutes,
                        0))
                players_damage_per_min[team].append(f'{damage_per_min:,} Dmg/min')

        self._players_damage_of_team_values = players_damage_of_team
        self._players_damage_per_min_values = players_damage_per_min
        return players_damage

    @cached_property
    def _players_damage_of_team(self) -> list[list[str]]:
        if self._players_damage_of_team_values is None:
            # noinspection PyStatementEffect
            self._players_damage

        return self._players_damage_of_team_values

    @cached_property
    def _players_damage_per_min(self) -> list[list[str]]:
        if self._players_damage_per_min_values is None:
            # noinspection PyStatementEffect
            self._players_damage

        return self._players_damage_per_min_values

    # noinspection PyTypeChecker,DuplicatedCode
    @cached_property
    def _players_vision(self) -> list[list[str]]:
        players_vision = [[], []]
        players_vision_per_min = [[], []]

        for team, players in enumerate(self._players):
            for player in players:
                players_vision[team].append(f'{player.stats.vision_score} Vision')

                if self._match_minutes == 0:
                    vision_per_min = player.stats.vision_score
                else:
                    vision_per_min = player.stats.vision_score / self._match_minutes
                players_vision_per_min[team].append(f'{vision_per_min:2.1f} Vis/min')

        self._players_vision_per_min_values = players_vision_per_min
        return players_vision

    @cached_property
    def _players_vision_per_min(self) -> list[list[str]]:
        if self._players_vision_per_min_values is None:
            # noinspection PyStatementEffect
            self._players_vision

        return self._players_vision_per_min_values

    # noinspection PyTypeChecker,DuplicatedCode
    @cached_property
    def _players_cs(self) -> list[list[str]]:
        players_cs = [[], []]
        players_cs_per_min = [[], []]

        for team, players in enumerate(self._players):
            for player in players:
                players_cs[team].append(f'{player.stats.total_minions_killed} CS')

                if self._match_minutes == 0:
                    cs_per_min = player.stats.total_minions_killed
                else:
                    cs_per_min = round(player.stats.total_minions_killed / self._match_minutes, 1)
                players_cs_per_min[team].append(f'{cs_per_min} CS/min')

        self._players_cs_per_min_values = players_cs_per_min
        return players_cs

    @cached_property
    def _players_cs_per_min(self) -> list[list[str]]:
        if self._players_cs_per_min_values is None:
            # noinspection PyStatementEffect
            self._players_cs

        return self._players_cs_per_min_values

    @cached_property
    def _players_items(self) -> list[list[list[str]]]:
        # region Static Data
        filler_item = hinter.UI.filler_image
        trinkets = [
            3340,  # Warding Totem
            3363,  # Farsight Alteration
            3364,  # Oracle Lens
        ]
        # endregion Static Data

        players_items = [[], []]

        for team, players in enumerate(self._players):
            for player in players:
                player_items = [
                    filler_item,
                    filler_item,
                    filler_item,
                    filler_item,
                    filler_item,
                    filler_item,
                    filler_item,
                    filler_item
                ]

                for key, item in enumerate(player.stats.items):
                    item: cassiopeia.core.match.Item

                    # Leave a blank above the trinket slot
                    if key > 2:
                        key += 1

                    if item is None:
                        player_items[key] = filler_item
                        continue

                    if item.id in trinkets:
                        player_items[7] = hinter.UI.load_image(
                            f'item-{item.id}',
                            hinter.data.constants.IMAGE_TYPE_PIL,
                            item.image,
                            size=hinter.data.constants.ICON_SIZE_ITEM,
                        )
                        continue

                    player_items[key] = hinter.UI.load_image(
                        f'item-{item.id}',
                        hinter.data.constants.IMAGE_TYPE_PIL,
                        item.image,
                        size=hinter.data.constants.ICON_SIZE_ITEM,
                    )

                players_items[team].append(player_items)

        return players_items

    # noinspection PyTypeChecker
    @cached_property
    def _players_key_runes(self) -> Union[list[list[str]], None]:
        players_key_runes = [[], []]
        players_secondary_rune_trees = [[], []]
        players_runes = [
            [
                [], [], [], [], [], [], [], []
            ],
            [
                [], [], [], [], [], [], [], []
            ]
        ]

        if self._queue == 'Arena':
            return None

        for team, players in enumerate(self._players):
            for player_spot, player in enumerate(players):
                secondary_found = False
                key_tree = None

                for rune in player.runes:
                    rune: cassiopeia.Rune

                    players_runes[team][player_spot].append(
                        hinter.UI.load_image(
                            f'rune-{rune.name}',
                            hinter.data.constants.IMAGE_TYPE_PIL,
                            rune.image,
                            size=hinter.data.constants.ICON_SIZE_RUNE,
                        )
                    )

                    if rune.is_keystone and key_tree is None:
                        key_tree = rune.path.name
                        players_key_runes[team].append(
                            hinter.UI.load_image(
                                f'rune-{rune.name}',
                                hinter.data.constants.IMAGE_TYPE_PIL,
                                rune.image,
                                size=hinter.data.constants.ICON_SIZE_RUNE,
                            )
                        )

                    if rune.path.name != key_tree and not secondary_found:
                        secondary_found = True
                        players_secondary_rune_trees[team].append(
                            hinter.UI.load_image(
                                f'rune-{rune.path.name}',
                                hinter.data.constants.IMAGE_TYPE_PIL,
                                rune.path,
                                size=hinter.data.constants.ICON_SIZE_SECONDARY_RUNE,
                            ))

        self._players_secondary_rune_trees_values = players_secondary_rune_trees
        self._players_runes_values = players_runes
        return players_key_runes

    @cached_property
    def _players_secondary_rune_trees(self) -> Union[list[list[str]], None]:
        if self._queue == 'Arena':
            return None

        if self._players_secondary_rune_trees_values is None:
            # noinspection PyStatementEffect
            self._players_key_runes

        return self._players_secondary_rune_trees_values

    @cached_property
    def _players_runes(self) -> Union[list[list[list[str]]], None]:
        if self._queue == 'ARENA':
            return None

        if self._players_runes_values is None:
            # noinspection PyStatementEffect
            self._players_key_runes

        return self._players_runes_values
